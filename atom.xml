<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>简素</title>
  
  <subtitle>Viva La Vida</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://mxdc.github.io/blog/"/>
  <updated>2020-04-29T16:01:05.211Z</updated>
  <id>https://mxdc.github.io/blog/</id>
  
  <author>
    <name>Jiyu Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo搭建个人博客</title>
    <link href="https://mxdc.github.io/blog/2020/04/28/Hexo-Next-Blog/"/>
    <id>https://mxdc.github.io/blog/2020/04/28/Hexo-Next-Blog/</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2020-04-29T16:01:05.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo搭建个人博客"><a href="#Hexo搭建个人博客" class="headerlink" title="Hexo搭建个人博客"></a>Hexo搭建个人博客</h1><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>首先根据<a href="https://hexo.io" target="_blank" rel="noopener">Hexo官方文档</a>安装<code>hexo</code>。<code>hexo</code>可以全局安装，也可以局部安装。安装好<code>hexo</code>后进行以下操作初始化项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** hexo会在指定的文件夹中创建项目 */</span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;youfolder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;youfolder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><p>查看文件目录结构如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.yml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scaffolds</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_drafts</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">_posts</span></span><br><span class="line"><span class="string">└──</span> <span class="string">themes</span></span><br><span class="line"></span><br><span class="line"><span class="string">/**</span></span><br><span class="line">  <span class="string">_config.yml</span> <span class="string">是站点配置文件。</span></span><br><span class="line">  <span class="string">pacakge.json</span> <span class="string">是项目和依赖包信息。</span></span><br><span class="line">  <span class="string">scaffolds</span> <span class="string">是模板文件夹，新建文章使用的模板。</span></span><br><span class="line">  <span class="string">source/_posts</span> <span class="string">是存放Markdown文章的目录。</span></span><br><span class="line">  <span class="string">themes</span> <span class="string">是主题文件夹。</span></span><br><span class="line"> <span class="string">*/</span></span><br></pre></td></tr></table></figure><p>更新依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** 更新全局依赖 */</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm update -g</span></span><br><span class="line"></span><br><span class="line">/** 更新项目依赖,在包含package.json</span><br><span class="line">的文件夹目录下面执行 */</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm update</span></span><br></pre></td></tr></table></figure><p>项目运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 本地启动服务器 *&#x2F;</span><br><span class="line">$  hexo server</span><br><span class="line">&#x2F;** 参数</span><br><span class="line"> *  -p,--port,默认4000</span><br><span class="line"> *  -s,--static,只使用静态文件</span><br><span class="line"> *  -l,--log,启用日志记录</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>下载主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** 进入你的项目目录 */</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span>  &lt;youfolder&gt;</span></span><br><span class="line"></span><br><span class="line">/** 在github上找到你要的主题 */</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next  themes/next</span></span><br><span class="line"></span><br><span class="line">/** 更新主题 */</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> themes/next</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure><p>主题配置</p><p>下载完主题后修改<code>_config.yml</code>文件中的<code>theme：</code>为你的主题</p><h2 id="自定义效果"><a href="#自定义效果" class="headerlink" title="自定义效果"></a>自定义效果</h2><ol><li>右上角GitHub Logo</li></ol><p>可以通过修改next主题配置文件添加github banner。</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/**</span> <span class="string">themes\next\_config.yml</span>  <span class="string">*/</span></span><br><span class="line"><span class="attr">github_baner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>网站<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">github-ribbons</a>和<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">github-corners</a>有github corner样式。<br>可以将样式复制到next主题对应的位置。位置可以通过查找<code>_config.yml</code>文件的配置文件关键词进行定位<br>实现效果如下所示:</p><p><img src="https://api.onedrive.com/v1.0/shares/s!AnfzhZ6EzsFXgUINwX8KysBXdEER/root/content" alt="github banner"></p><ol start="2"><li>添加RSS</li></ol><p><code>hexo-generator-feed</code>是<code>hexo</code>的一个RSS插件。执行以下命令安装插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo搭建个人博客&quot;&gt;&lt;a href=&quot;#Hexo搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;Hexo搭建个人博客&quot;&gt;&lt;/a&gt;Hexo搭建个人博客&lt;/h1&gt;&lt;h2 id=&quot;初始化项目&quot;&gt;&lt;a href=&quot;#初始化项目&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://mxdc.github.io/blog/tags/hexo/"/>
    
      <category term="Next-Theme" scheme="https://mxdc.github.io/blog/tags/Next-Theme/"/>
    
  </entry>
  
  <entry>
    <title>研学报告</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/%E7%A0%94%E5%AD%A6%E6%8A%A5%E5%91%8A/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/%E7%A0%94%E5%AD%A6%E6%8A%A5%E5%91%8A/</id>
    <published>1970-01-01T00:00:00.189Z</published>
    <updated>2020-04-29T16:56:31.924Z</updated>
    
    <content type="html"><![CDATA[<h4 id="筑梦扬帆——海外研学报告"><a href="#筑梦扬帆——海外研学报告" class="headerlink" title="筑梦扬帆——海外研学报告"></a>筑梦扬帆——海外研学报告</h4><p>​        “读万卷书，行万里路”，此次研学之路，不仅实现了我海外研学交流的梦想，也开拓了我的国际视野、丰富了我的学习阅历。也正是国家给我们扬起了筑梦之帆，让我们获得了更多全面发展自身的机会和动力，作为一名在校大学生，我们应该树立远大的理想，不管以后工作或者是继续研学，我们应该不断提高自己，为社会和国家做出贡献，在实现自身梦想的同时，共筑伟大的中国梦。</p><p>​        大二的时候经过学院的筛选和推荐，有机会能参加”逐梦扬帆”项目，但是没能通过学校的选拔，当时虽然有点遗憾。但是，经过一年的努力，我不仅通过学院的筛选，也通过了国际办和学工处的面试。当接到面试通过的消息后，想到在大学期间能有机会去海外研学开拓视野，心情是无比的激动与感激。感激省和高校能给我们提供这个机会，也感激在大学期间自己不断的努力。</p><p>​        经过面试后，接下来是繁琐的行前准备。准备的各种资料有点繁琐，但在准备的过程中，不仅从同行的伙伴学到好多，也提高了自身的能力和效率。在准备面签材料的时候，大家有时候会遇到一些相同的问题，为了避难重复提问，我们第一次协作，在线维护了一份签证材料疑问汇总文档。通过这次材料准备也暴露出了自己做事没有思考全面，很多同学和我一样材料改了又改，现在想想如果当时自己能再检查检查，再多问问就不会跑这么多冤枉路了。</p><p>​    在正式出发的当天,老师们给我们开了行前会议后，我们带着满腔热血和期待，开启了研学的旅程。午饭过后我们在莲花港乘船到香港机场，乘风破浪，筑梦扬帆，心中已是满怀期待和遐想。到达机场，通过安检我们来到了候机大厅，等了三个多小时后我们终于登机，开启十七个小时的飞机之旅。随着飞机进入跑道，慢慢加速，远离地面，心情无比的激动与开心，我们终于翱翔上蓝天了。第一次做飞机，此时我从飞机的舷窗向外望，近在咫尺的白云像棉花糖一样，鸟瞰这窗外，让我感到祖国的广阔天地无限的美好，心情无比的舒畅。十七个小时过后我们到达波士顿机场，此时波士顿晚上十点半了，通过安检拿完行李后我们跟随Harry老师乘坐大巴来到Courtyard酒店，令人心动的研学之路正式开始！在车上harry老师和导游给我们讲了一些注意事项，随后我们到达酒店已是深夜。入住酒店后，首先感受到差异的是美国的温度使用华氏温度，调空调调了好久。整理好行李准备洗漱，正如Harry老师和导游所说的美国的浴室是没有地漏的。让很多人不习惯的是，这边是不喝热水的，还好有咖啡机可以煮热水。感受着东西的差异，虽然做了十七个小时的飞机，休息了四五个小时后依然不觉疲惫，满怀期待迎接研学的第一天。</p><p>​    用完早餐后，我们在会议室举行了开营仪式，老师们和我们讲解了接下来几天在波士顿的行程以及我们在外出时应当注意的事项。下午，我们开始了波士顿最精华的学习之旅，重走“自由之路”。从波士顿公园，沿着红砖标出的路线，我们经过了谷仓墓地，进入了国王礼拜堂简要参观，在波士顿第一座公立学校波士顿拉丁学校（Boston Latin School）旧址瞻仰了本杰明·富兰克林雕像，紧接着我们来到了以美食闻名的昆西市场。在这里我们体会到了美国的街头文化，昆西市场周边有很多街头艺人，有表演杂技的，有唱歌跳舞的，用行为艺术的，十分有创意。离开昆西市场后，我们继续走在“自由的路上”，最后我们来到了著名的邦克山纪念碑，顺着弯曲阶梯拾级而上，我到达了邦克山纪念碑的最顶端，尽收波士顿的美景。走完自由之路后，我们用拿到的54美元现金去自主体验购餐。</p><p>​    美国研学的第三天，早上我们来到了我期待已久的大学哈佛大学。进入哈佛校园映入眼帘的是各种各样的红砖房，身处其中有种高雅宁静的感觉。跟随着导游的脚步我们来到哈佛铜像前，哈佛雕像底座刻着三行字「约翰哈佛，建校者，1638年」。底座左侧并刻有哈佛校徽：用倒三角形排列三本打开的书，书上刻有七个拉丁字母「VERITAS」，意为「真理」。哈佛不是神话，哈佛只是一个证明，人的意志，精神，抱负，理想的证明。随后我们来到坐落在图书馆建筑一侧著名的中国汉白玉石碑。岁月侵蚀，风化的石碑呈现裂纹。看着石碑，看着游人在碑前留影，总有一种说不出的自豪。可能这是唯一 一块来自中国的石碑，石碑立在那里，历经沧桑，见证了多少事。下午，在Harry老师的带领下，我们来到了麻省理工学院（MIT）——这个科学家的摇篮、世界顶尖的研究院，开始了我们的MIT之旅。Harry老师先是带着我们参观MIT校园内著名的建筑，包括基利安庭院（Killian Court）、MIT大圆顶（Great Dome）、看起来倾斜的蛐蛐楼、图书馆等等，带我们领略MIT的风采。紧接着，我们便开始了Mistery Hunt Game。这是一个考验团队合作、策略制定、方向感以及体力的游戏，类似于国内的定向越野，各个小组需要在规定时间内找到MIT的指定建筑。我们在校园里边奔跑着寻找答案，边询问MIT的学生。这次活动开始了我们小组的第一次合作，通过努力和合作我们找到了部分答案，虽然没有获得第一名，但是加深了我们彼此的认识和友谊。同时对MIT也有进一步的了解。在哈佛课堂的前一晚，Harry老师带领我们进入了case study的学习，针对分析问题逻辑思维和总结论述能力给我们提出了建议。通过这次学习，让我懂得要擅于问Why去深入理解问题，利用MECI的原则将问题分解为相互排斥但总体包含的类别，按照逻辑顺序逐步分析解决问题。</p><p>​        能在哈佛上课，是我最期待的事情。在哈佛上课的两天也是我收获最多的两天。这两天给我们上课的教授是哈佛大学的哈佛终身教授Prithwiraj Choudhury，这让我感到非常荣幸。第一天的课程主要是围绕“How to Do a business plan ”和“mechine learning”来展开的，教授针对我们的授课风格是深入浅出的，通过生动的案例和幽默的语言让我们快速理解这些商业知识点。第一次真真切切的感受到什么是真正的哈佛课堂，跟国内大学上课的模式和教学形式真的有很大的不同，在哈佛的课堂上，氛围是轻松随意的。到了晚上，我们组进行合作讨论，大家都尽自己最大的努力去完成明天要展示的商业计划书，到了凌晨大家都很困了，但大家都坚持着完善商业计划书。哈佛课堂的第二天我们还有一早上完善我们的商业计划书，下午是商业计划书的展示。在这次商业计划书的准备和展示过程中，心里感到极度的压力。后来Harry跟我们说哈佛和哥大的学生每天都经历这样的压力，上课前一天晚上老师给学生发一百多页的pdf必须读了。这让我觉得和哈佛和哥大的学生还差很远。同过这两天的学习，也让我们发现了自身的许多不足之处。在后来的行程中，非常感谢Harry能给我们单独的辅导，解决自身的问题和不足。</p><p>​        紧张的哈佛课堂后，我们整理行装出发前往纽黑文参观著名的耶鲁大学。参观完耶鲁大学后，我们乘车来到了纽约。在晚餐过后，我们在会议室进行了纽约人文知识竞赛，接着Joyce老师带着零食给我们并和我们进行了面对面交流。在交流中同学和Joyce老师给我的收获良多，Joyce不仅指出了我们在哈佛课堂发现的问题也给我们提出以下四点建议。一是克服语言障碍。同学们需要将自己已学的英语知识放在语境中活学活用，并反复练习，比如和同学打赌进行日常口语交流。二是提高思维能力。同学们在presentation的时候需要理清所要传达内容的框架和层次。比如一开始先用简单的语言概括所讲的内容，再接着细化内容。三是提高公众演讲能力。在presentation的时候，学生们多存在不够自信，语气，仪态不够自然的问题，因此需要多加注意这些方面的提高。比如可以参加一些public speech的workshop，通过刻意练习来提高。四是提高聆听和总结能力。在上完哈佛商业课程后，可以尝试总结、复述老师所讲内容的框架，这可以检测自己抓取重要信息的能力，有没有真正理解老师所讲内容。</p><p>​    我们有幸参观了世界四大博物馆之一的美国纽约大都会艺术博物馆。在这里我看到了自梵高，莫奈，达芬奇，高庚等各国画家之手的作品。到中国馆时，能看到中国很多古老的文物而为感到自豪,但为它们远在异国而感到沉重。下午我们来到了联合国，走进联合国的花园，首先看到的是一只打结的枪杆和一个破碎的地球。打结的枪杆是卢森堡在1988年赠给联合国的，这一雕塑的含义很明白，那就是制止战争，禁止杀戮。“破碎的地球”则是意大利政府赠送给联合国的。以此警示世人，如果不及时控制环境污染，控制人口增长，地球就会千疮百孔。它们都代表了世界各国人民千百年来渴望和平的美好梦想。在这里我们看了中国赠送给联合国的礼物——世纪宝鼎。虽然我们只能在内部远远观看，并没看清它的细节与修饰，但我们能够知道它表达了中国人民对联合国的美好祝愿，对创造一个更加美好的新世纪的希冀。</p><p>​    在行程的最后一站，我们来到了一个被全世界航空航天爱好者尊为“圣地”的美国国家航空航天博物馆。通过安检,我们来到主厅,映入眼帘的各种航天航空飞行器让我感到震惊。第一款有人驾驶的超音速飞机、美国第一架喷射战斗机,第一架成功的私人航天器太空船一号(Space Ship One), 人造地球卫星1号的复制品，每一件展品都是名副其实的里程碑，都曾经在航空航天史上留下了浓墨重彩的一笔。人类在航天飞行、探索宇宙的道路上从未停止过脚步,迄今为止的一个世纪里,人类在航空航天飞行的发展日益进步,虽然我们没有见证伟大历史时刻的时候,但这里 ,替我们保留了那个时代航空航天事业的辉煌,从莱特兄弟的第一架飞机，到阿波罗登月舱，见证了人类从征服天空到踏步外星球的过程。</p><p>​    “筑梦扬帆”， 也正是国家给我们扬起了筑梦之帆，让我们开阔了国际视野获得了更多全面发展自身的机会和动力，作为一名在校大学生，我们应该树立远大的理想，不管以后工作或者是继续研学，我们应该不断提高自己，为社会和国家做出贡献，在实现自身梦想的同时，共筑伟大的中国梦。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;筑梦扬帆——海外研学报告&quot;&gt;&lt;a href=&quot;#筑梦扬帆——海外研学报告&quot; class=&quot;headerlink&quot; title=&quot;筑梦扬帆——海外研学报告&quot;&gt;&lt;/a&gt;筑梦扬帆——海外研学报告&lt;/h4&gt;&lt;p&gt;​        “读万卷书，行万里路”，此次研学之路，不仅
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Install using the repository</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/Install%20using%20the%20repository/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/Install%20using%20the%20repository/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T17:39:22.902Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE<br>即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 stable, test, 和 nightly 三个更新频道。每六个月发布一个 stable<br>版本 (18.09, 19.03, 19.09…)。</p><blockquote><p>The Docker Engine - Community package is now called <code>docker-ce</code>.</p></blockquote><h4 id="Centos-安装docker-ce"><a href="#Centos-安装docker-ce" class="headerlink" title="Centos 安装docker-ce"></a><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Centos 安装docker-ce</a></h4><p>You can install Docker Engine - Community in different ways, depending on your needs:</p><ul><li>Most users <a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository" target="_blank" rel="noopener">set up Docker’s repositories</a> and install from them, for ease of installation and upgrade tasks. <strong>This is the recommended approach.</strong></li><li>Some users download the RPM package and <a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-from-a-package" target="_blank" rel="noopener">install it manually</a> and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet.</li><li>In testing and development environments, some users choose to use automated <a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-convenience-script" target="_blank" rel="noopener">convenience scripts</a> to install Docker.</li></ul><h3 id="Install-using-the-repository"><a href="#Install-using-the-repository" class="headerlink" title="Install using the repository"></a>Install using the repository</h3><p>Before you install Docker Engine - Community for the first time on a new host machine, *<em>you need to set up the Docker repository. *</em>Afterward, you can install and update Docker from the repository.</p><h4 id="SET-UP-THE-REPOSITORY"><a href="#SET-UP-THE-REPOSITORY" class="headerlink" title="SET UP THE REPOSITORY"></a>SET UP THE REPOSITORY</h4><ol><li><p>Install required packages. <code>yum-utils</code> pro<em>v</em>ides the <code>yum-config-manager</code> utility, and <code>device-mapper-persistent-data</code> and <code>lvm2</code> are required by the <code>devicemapper</code> storage driver.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure></li><li><p>Use the following command to set up the <strong>stable</strong> repository.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">--add-repo \</span><br><span class="line">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $ sudo yum-config-manager \</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --add-repo \</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="INSTALL-DOCKER-ENGINE-COMMUNITY"><a href="#INSTALL-DOCKER-ENGINE-COMMUNITY" class="headerlink" title="INSTALL DOCKER ENGINE - COMMUNITY"></a>INSTALL DOCKER ENGINE - COMMUNITY</h4><ol><li><p>Install the <em>latest version</em> of Docker Engine - Community and containerd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li></ol><h4 id="Start-Docker"><a href="#Start-Docker" class="headerlink" title="Start Docker."></a>Start Docker.</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 Docker CE</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h4&gt;&lt;p&gt;Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），E
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/README/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/README/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T17:39:22.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="md"><a href="#md" class="headerlink" title="md"></a>md</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>md</p><h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><p>软件架构说明</p><h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol><li>xxxx</li><li>xxxx</li><li>xxxx</li></ol><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol><li>xxxx</li><li>xxxx</li><li>xxxx</li></ol><h4 id="Jenkins使用说明"><a href="#Jenkins使用说明" class="headerlink" title="Jenkins使用说明"></a>Jenkins使用说明</h4><ol><li></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;md&quot;&gt;&lt;a href=&quot;#md&quot; class=&quot;headerlink&quot; title=&quot;md&quot;&gt;&lt;/a&gt;md&lt;/h1&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;md&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vim-learn</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/vim-learn/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/vim-learn/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T17:39:23.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ctrl-c-Es"><a href="#ctrl-c-Es" class="headerlink" title="ctrl + c === Es"></a>ctrl + c === Es</h3><h3 id="改键位"><a href="#改键位" class="headerlink" title="改键位"></a>改键位</h3><p>× 进入家目录。<br>× 进入.vim文件夹，如果没有则创建.vim文件夹。<br>× 创建vimrc文件。<br>× noremap 更改键位命令。</p><blockquote><p>eg: <code>noremap a b</code> 用a替换b。当你按a时，vim会认为你按了b。</p></blockquote><h4 id="更改常用键"><a href="#更改常用键" class="headerlink" title="更改常用键"></a>更改常用键</h4><ul><li>vim原先 h j k l 分别对于 左下上右 可以通过 norempa更改</li><li>norempa i k</li><li>noremap k j</li><li>noremap j h</li><li>noremap <h4 id="命令快捷键"><a href="#命令快捷键" class="headerlink" title="命令快捷键"></a>命令快捷键</h4></li><li>map S :w<CR>  # 用大写S替换:w回车(<CR>),快速保存。</li><li>map s <nop> # 小写s，不执行指令。</li><li>map Q :q<CR> #大写Q，替换:q回车，快速退出。</li><li>map R :source $HOME/.vim/vimrc, 重新加载vimrc配置文件当前文件。<h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h4><operation> <motion></li><li>a 删除：d3l-d是删除操作 3是删除字符数 l是删除的方向,dd是剪切整行，p是粘贴</li><li>G 文尾行。</li><li>o 新建一行 大写前，小写后</li><li>y 是复制</li><li>p 是粘贴 大写前,小写后。</li><li>c 是 change 修该,cw修改一个词，ciw–(change in word) 在单词中修改。ci””–在引号中修改。di””</li><li>x 是删除。</li><li>w 下一个单词，b上一个单词。 </li><li>u 是撤销操作。</li><li>J 合并两行。 </li><li>f 查找。可以跟 d y结合使用。</li><li>/字符串全文查找。:noh取消高亮。<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4>github上的 vim-plug是插件管理软件。</li></ul><h4 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h4><pre><code>可视化模式有三种。* v-line ,按shit+v.选完行后可以输入:normal A.png(所选中的行后面都加.png) 指令进行按行批量操作。:normal Kstring。K是在前面添加</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ctrl-c-Es&quot;&gt;&lt;a href=&quot;#ctrl-c-Es&quot; class=&quot;headerlink&quot; title=&quot;ctrl + c === Es&quot;&gt;&lt;/a&gt;ctrl + c === Es&lt;/h3&gt;&lt;h3 id=&quot;改键位&quot;&gt;&lt;a href=&quot;#改键位&quot; class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/test/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/test/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T17:39:23.030Z</updated>
    
    <content type="html"><![CDATA[<p>testv1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;testv1&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/Builder Pattern</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Builder%20Pattern/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Builder%20Pattern/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.563Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue/Vue-router</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/vue/Vue-router/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/vue/Vue-router/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.834Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/Factory Pattern</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Factory%20Pattern/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Factory%20Pattern/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Simple-Factory"><a href="#Simple-Factory" class="headerlink" title="Simple Factory"></a>Simple Factory</h1><h2 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt=""></p><ul><li><p>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例</p></li><li><p>简单工厂又叫静态工厂</p></li><li><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。（封装实例化代码）</p></li></ul><h1 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h1><h2 id="动机（Motivation）-1"><a href="#动机（Motivation）-1" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h2><p>  在工厂类定义一个抽象方法，将具体产品的创建过程交给专门的工厂子类去完成。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</p><h2 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h2><p>工厂方法模式包含如下角色：</p><ul><li><p>Product：抽象产品</p></li><li><p>ConcreteProduct：具体产品</p></li><li><p>Factory：抽象工厂</p></li><li><p>ConcreteFactory：具体工厂</p><p><img src="https://api.onedrive.com/v1.0/shares/s!AnfzhZ6EzsFXgTbPGsGrUoYtNWUD/root/content" alt=""></p></li></ul><h2 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h2><p><img src="https://api.onedrive.com/v1.0/shares/s!AnfzhZ6EzsFXgTgU3thdrq7tiNTp/root/content" alt="ew"></p><ul><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</p><p><img src="https://api.onedrive.com/v1.0/shares/s!AnfzhZ6EzsFXgTQizNzUFvXA6PBc/root/content" alt="ss"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Simple-Factory&quot;&gt;&lt;a href=&quot;#Simple-Factory&quot; class=&quot;headerlink&quot; title=&quot;Simple Factory&quot;&gt;&lt;/a&gt;Simple Factory&lt;/h1&gt;&lt;h2 id=&quot;动机（Motivation）&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/Singleton Pattern</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Singleton%20Pattern/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Singleton%20Pattern/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h1><h2 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h2><ul><li>一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</li><li>如何保证一个类只有一个实例并且这个实例易于被访问呢？</li><li><strong>一个更好的解决办法是让类自身负责保存它的唯一实例。</strong>这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>单例模式(Singleton Pattern)：单例模式确保某一个类<strong>只有一个实例</strong>，而且<strong>自行实例化</strong>并向整个系统<strong>提供这个实例</strong>，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 </p><h2 id="单列模式种实现方式"><a href="#单列模式种实现方式" class="headerlink" title="单列模式种实现方式"></a>单列模式种实现方式</h2><p>1）饿汉式（静态常量）<br>2）饿汉式（静态代码块）<br>3）懒汉式（线程不安全）<br>4）懒汉式（线程安全，同步方法，）<br>5）懒汉式（线程安全，同步代码块，不能实现）<br>6）双重检查<br>7）静态内部类<br>8）枚举</p><ol><li><p><strong>饿汉式(静态常量)应用实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2. 实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton()</span><br><span class="line">    <span class="comment">// 3. 对外提供一个公有的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：写法简单，类加载时就实例化，没有多线程同步问题。</p><p>缺点：没有Lazy Loading效果，可能会浪费空间</p></li><li><p><strong>饿汉式(静态代码块)应用实例</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">static</span> &#123;singleton = <span class="keyword">new</span> Singletion() &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3. 对外提供一个公有的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点同上。</p><ol start="3"><li><p><strong>懒汉式（线程不安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3. 对外提供一个公有的静态方法，用到时才实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程可以使用，多线程不安全（多个线程进入if代码块会生成多个实例），开发不要使用。</p></li><li><p><strong>懒汉式（同步方法）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3. 对外提供一个公有的静态方法，用到时才实例化,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">         <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="comment">// synchronized (Singleton.class)&#123;singleton = new Singleton();&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法进行同步效率低(后面获取实例都要进行同步)，</p></li><li><p>双重检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3. 对外提供一个公有的静态方法，用到时才实例化,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用，实现懒加载。线程安全</p></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 外部类加载内部类不会加载，实现懒加载</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">SingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3. 对外提供一个公有的静态方法，用到时才实例化,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以防止反序列化，线程安全</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Singleton-Pattern&quot;&gt;&lt;a href=&quot;#Singleton-Pattern&quot; class=&quot;headerlink&quot; title=&quot;Singleton Pattern&quot;&gt;&lt;/a&gt;Singleton Pattern&lt;/h1&gt;&lt;h2 id=&quot;动机（Mo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/Strategy</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Strategy/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Strategy/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.567Z</updated>
    
    <content type="html"><![CDATA[<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><h4 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</li></ul><ul><li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。</li><li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</li></ul><ul><li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h4&gt;&lt;h4 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/Template Method</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Template%20Method/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Template%20Method/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h1><h2 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h2><ul><li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</li><li>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义一个操作中的算法的骨架 <strong>(稳定)</strong> ，而将一些步骤延迟 <strong>(变化)</strong> 到子类中。 Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的 某些特定步骤。 ——《 设计模式》 GoF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Template-Method&quot;&gt;&lt;a href=&quot;#Template-Method&quot; class=&quot;headerlink&quot; title=&quot;Template Method&quot;&gt;&lt;/a&gt;Template Method&lt;/h1&gt;&lt;h2 id=&quot;动机（Motivation
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/Prototype Pattern</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Prototype%20Pattern/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Prototype%20Pattern/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h1><h2 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h2><p>克隆羊问题</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>spring 中bena的scope为prototype</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>clone是浅拷贝</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul><li><p>重写clone方法，对引用类型单独处理</p></li><li><p>序列化，工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。</p></li><li><p>使用第三方jar包转化为json数据，在转为对象</p></li><li><p>Apache Commons Lang序列化</p></li><li><pre><code class="java"> <span class="comment">//写入字节流</span>ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();ObjectOutputStream obs = <span class="keyword">new</span>   ObjectOutputStream(out);obs.writeObject(obj);obs.close();<span class="comment">//分配内存，写入原始对象，生成新对象</span> ByteArrayInputStream ios = <span class="keyword">new</span>  ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);<span class="comment">//返回生成的新对象</span>cloneObj = (T) ois.readObject();ois.close();</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型模式（Prototype-Pattern）&quot;&gt;&lt;a href=&quot;#原型模式（Prototype-Pattern）&quot; class=&quot;headerlink&quot; title=&quot;原型模式（Prototype Pattern）&quot;&gt;&lt;/a&gt;原型模式（Prototype Pa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/面向对象设计原则</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.648Z</updated>
    
    <content type="html"><![CDATA[<h5 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h5><p><strong>依赖反转原则</strong>（Dependency inversion principle，DIP）是指一种特定的<a href="https://zh.wikipedia.org/wiki/耦合性_(計算機科學)" target="_blank" rel="noopener">解耦</a>（传统的<a href="https://zh.wikipedia.org/wiki/耦合性_(計算機科學)" target="_blank" rel="noopener">依赖</a>关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，<strong>使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</strong></p><p><img src="https://api.onedrive.com/v1.0/shares/s!AnfzhZ6EzsFXgTBeNbO00GdCqHUS/root/content" alt="依赖倒置"></p><p><strong>图1中，高层对象A依赖于底层对象B的实现；图2中，把高层对象A对底层对象的需求抽象为一个接口A，底层对象B实现了接口A，这就是依赖反转。</strong></p><p>该原则规定：</p><ol><li>高层次的模块(稳定)不应该依赖于低层次的模块(<strong>低层实现细节是变化的</strong>)，两者都应该依赖于<a href="https://zh.wikipedia.org/wiki/抽象化_(計算機科學)" target="_blank" rel="noopener">抽象接口</a>。(稳定)</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol><p><img src="https://api.onedrive.com/v1.0/shares/s!AnfzhZ6EzsFXgTfOWbQr--Rw72Lv/root/content" alt="依赖图"></p><blockquote><p>具体实现时变化的，如果高层次模块模块或者抽象模块依赖于具体实现，系统就会变的不稳定。依赖倒置原则可以把实现细节隔离。</p></blockquote><h5 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h5><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><h5 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h5><p><strong>单一功能(职责)原则</strong>（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。</p><ul><li>一个类应该仅有一个引起它变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><h5 id="Liskov-替换原则-LSP"><a href="#Liskov-替换原则-LSP" class="headerlink" title="Liskov 替换原则(LSP)"></a>Liskov 替换原则(LSP)</h5><ul><li>子类必须能够替换它们的基类(IS-A)。</li><li>继承表达类型抽象。</li></ul><h5 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h5><p><strong>接口隔离原则</strong>（英语：interface-segregation principles， 缩写：ISP）指明客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为<strong>角色接口</strong>（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。</p><ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/程序设计" target="_blank" rel="noopener">程序设计</a>领域， <strong>SOLID</strong>（<strong>单一功能、开闭原则、里氏替换、接口隔离</strong>以及<strong>依赖反转</strong>）是由<a href="https://zh.wikipedia.org/w/index.php?title=Robert_C._Martin&action=edit&redlink=1" target="_blank" rel="noopener">罗伯特·C·马丁</a>在21世纪早期<a href="https://zh.wikipedia.org/wiki/SOLID_(面向对象设计)#cite_note-metz-presentation-2009-1" target="_blank" rel="noopener">[1]</a> 引入的<a href="https://zh.wikipedia.org/wiki/记忆术" target="_blank" rel="noopener">记忆术</a><a href="https://zh.wikipedia.org/wiki/首字母缩略字" target="_blank" rel="noopener">首字母缩略字</a><a href="https://zh.wikipedia.org/wiki/SOLID_(面向对象设计)#cite_note-ub-old-web-solid-2" target="_blank" rel="noopener">[2]</a><a href="https://zh.wikipedia.org/wiki/SOLID_(面向对象设计)#cite_note-ub-solid-3" target="_blank" rel="noopener">[3]</a>，指代了<a href="https://zh.wikipedia.org/wiki/面向对象编程" target="_blank" rel="noopener">面向对象编程</a>和<a href="https://zh.wikipedia.org/wiki/面向对象设计" target="_blank" rel="noopener">面向对象设计</a>的五个基本原则。</p></blockquote><h5 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</h5><p>优先使用对象组合，而不是类继承</p><ul><li><p>类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。</p></li><li><p>继承在某种程度上破坏了封装性，子类父类耦合度高。</p></li><li><p>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</p></li></ul><hr><ol><li>封装变化点</li></ol><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul><ol start="2"><li>针对接口编程，而不是针对实现编程</li></ol><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。</li></ul><hr><p>将设计原则提升为设计经验</p><ol><li><p>设计习语 Design Idioms</p><p>Design Idioms 描述与特定编程语言相关的低层模式，技巧、惯用法</p></li><li><p>设计模式 Design pattern</p><p>Design pattern 主要描述的是类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等</p></li><li><p>架构模式 Architectural pattern</p><p>Architectural pattern描述的是系统中与基本机构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们自己的关系的规则</p></li></ol><blockquote><p>重构获得模式</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;依赖倒置原则-DIP&quot;&gt;&lt;a href=&quot;#依赖倒置原则-DIP&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置原则(DIP)&quot;&gt;&lt;/a&gt;依赖倒置原则(DIP)&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;依赖反转原则&lt;/strong&gt;（Dependency i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>algorithms/algorithms</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/algorithms/algorithms/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/algorithms/algorithms/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="散列表"><a href="#散列表" class="headerlink" title=" 散列表"></a> 散列表</h2><p>:earth_asia: <strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<a href="https://zh.wikipedia.org/wiki/鍵" target="_blank" rel="noopener">键</a>（Key）而直接访问在内存存储位置的<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a href="https://zh.wikipedia.org/wiki/散列函数" target="_blank" rel="noopener">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p><blockquote><p>使用散列的查找算法分两步。第一步是用散列函数将查找的键转化为数组索引。如果有冲突，散列查找的第二步就是处理碰撞冲突</p></blockquote><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>:earth_asia:<strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a href="https://zh.wikipedia.org/wiki/函数" target="_blank" rel="noopener">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。:</p><h2 id="除留余法"><a href="#除留余法" class="headerlink" title="除留余法  "></a>除留余法  </h2><p>将整数散列最常用的方法是除留余法。选择大小为<strong>素数</strong>M的数组，对于任意正整数k,计算<code>k%M</code><br>键为0~1之间的实数，将键表示为二进制数后在使用除留余法(java就是这么做的)。<br>字符串也可以使用除留余法。一种叫Horner方法的经典算法用N次乘法、加法和取余来计算一个字符串的散列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">String s = <span class="string">"nanbnddgadgnnnadsgaaaagqqqqqqqnqqqn"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    hash = (R*hash +s.charAt(i)) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Horner 算法是以英国数学家 William George Horner 命名的一种多项式求值的快速算法，实际上，这种快速算法在他之前就已经被Paolo Ruffini使用过了。而中国数学家秦九韶提出这种算法要比William George Horner 早600多年。</p><p><img src="https://raw.githubusercontent.com/MXDC/images_bed/master/img/1567099032709.jpg" alt="1567099032709"></p></blockquote><h2 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h2><p>一种碰撞处理的方法就是将大小为M的数组中的没过元素指向一个链表，链表中的每个节点都储存该元素的<strong>键值对</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot; 散列表&quot;&gt;&lt;/a&gt; 散列表&lt;/h2&gt;&lt;p&gt;:earth_asia: &lt;strong&gt;散列表&lt;/strong&gt;（&lt;strong&gt;Hash table&lt;/strong&gt;，也叫
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>blog/需求分析</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/blog/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/blog/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.686Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><h5 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h5><ol><li><p>界面好看</p></li><li><p>简洁</p></li><li><p>方便查看博客</p></li><li><p>有创意</p></li><li><p>可以看有道云笔记，印象笔记，腾讯云笔记</p><p>用例图:</p></li></ol><h5 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h5><pre><code>1. 管理员登录管理，集成微信登录2. 可以上传博客和基本的增删改查</code></pre><h4 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h4><h5 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h5><p>#####数据库ER 图</p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>First, add the MySQL Yum repository to your system’s repository list. Follow these steps:</p><ol><li>Go to the download page for MySQL Yum repository at <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a>.</li><li>Select and download the release package for your platform.</li><li>Install the downloaded release package with the following command,</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h4&gt;&lt;h5 id=&quot;前台&quot;&gt;&lt;a href=&quot;#前台&quot; class=&quot;headerlink&quot; title=&quot;前台&quot;&gt;&lt;/a&gt;前台&lt;/h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java/java动态代理</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/java/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/java/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.689Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><hr><p>给某一个对象提供一个代理对象，让代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;给某一个对象提供一个代理对象，让代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux/bash shell命令</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/linux/bash%20shell%E5%91%BD%E4%BB%A4/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/linux/bash%20shell%E5%91%BD%E4%BB%A4/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.714Z</updated>
    
    <content type="html"><![CDATA[<h4 id="bash-shell命令"><a href="#bash-shell命令" class="headerlink" title="bash shell命令"></a>bash shell命令</h4><h4 id="程序管理"><a href="#程序管理" class="headerlink" title="程序管理"></a>程序管理</h4><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>报告单前系统的进程状态</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps 选项</span><br></pre></td></tr></table></figure><h6 id="选项"><a href="#选项" class="headerlink" title="选项"></a><strong>选项</strong></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A : 显示所有程序</span><br></pre></td></tr></table></figure><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep ssh # ps 与grep 常用组合用法，查找特定进程</span><br><span class="line">ps -C nginx # 通过名字或命令搜索进程</span><br></pre></td></tr></table></figure><h4 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h4><h5 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h5><p>网络配置工具 </p><h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip (选项)(参数)</span><br></pre></td></tr></table></figure><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip link show # 显示网络接口信息</span><br><span class="line">ip link set eth0 up #开启网卡</span><br><span class="line">ip link set ehh0 down</span><br><span class="line">ip addr show # 显示网卡ip信息</span><br></pre></td></tr></table></figure><hr><h5 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h5><p>Linux 上新用的防火墙软件，跟iptables差不多</p><h6 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd [选项 ]</span><br></pre></td></tr></table></figure><h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装firewalld</span></span><br><span class="line">yum install firewalld firewall-config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动,状态查看,停止,禁用</span></span><br><span class="line">systemctl start|status|disable|stop firewalld</span><br></pre></td></tr></table></figure><h6 id="端口管理"><a href="#端口管理" class="headerlink" title="端口管理"></a>端口管理</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开443/TCP端口</span></span><br><span class="line">firewall-cmd --add-port=443/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久打开3690/TCP端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=3690/tcp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 --permanent参数 需要reload一下，临时打开的端口erload后失效</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙,添加的端口可以看到</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;bash-shell命令&quot;&gt;&lt;a href=&quot;#bash-shell命令&quot; class=&quot;headerlink&quot; title=&quot;bash shell命令&quot;&gt;&lt;/a&gt;bash shell命令&lt;/h4&gt;&lt;h4 id=&quot;程序管理&quot;&gt;&lt;a href=&quot;#程序管理&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/什么是设计模式</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.646Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h5><p><em>Christopher</em> Alexander 说过：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。</p><h5 id="深入理解面向对象"><a href="#深入理解面向对象" class="headerlink" title="深入理解面向对象"></a>深入理解面向对象</h5><ul><li><p>向下：深入理解面向对象机制</p><ul><li>封装，隐藏内部实现</li><li>继承，复用现有代码</li><li>多态，改写对象行为</li></ul></li><li><p>向上：深刻把握面向对象机制所带来的抽象意义，如何使用这种机制来表达现实世界</p></li></ul><h5 id="如何解决决复杂性"><a href="#如何解决决复杂性" class="headerlink" title="如何解决决复杂性"></a>如何解决决复杂性</h5><ul><li>分解（不易复用）</li><li>抽象（可以使用同一 方法复用）</li></ul><p>以下分类来自<a href="http://design-patterns.readthedocs.org/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a></p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p><p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p><p><strong>包含模式</strong>(6种)</p><ul><li><p>简单工厂模式（Simple Factory）</p><p>  重要程度：4 （5为满分）</p></li><li><p>工厂方法模式（Factory Method）</p><p>  重要程度：5</p></li><li><p>抽象工厂模式（Abstract Factory）</p><p>  重要程度：5</p></li><li><p>建造者模式（Builder）</p><p>  重要程度：2</p></li><li><p>原型模式（Prototype）</p><p>  重要程度：3</p></li><li><p>单例模式（Singleton）</p><p>  重要程度：4</p></li></ul><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。</p><p>结构型模式可以分为类结构型模式和对象结构型模式：</p><ul><li>类结构型模式关心类的组合，由多个类可以组合成一个更大的</li></ul><p>系统，在类结构型模式中一般只存在继承关系和实现关系。 - 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。</p><p><strong>包含模式</strong>(7种)</p><ul><li><p>适配器模式(Adapter)</p><p>  重要程度：4</p></li><li><p>桥接模式(Bridge)</p><p>  重要程度：3</p></li><li><p>组合模式(Composite)</p><p>  重要程度：4</p></li><li><p>装饰模式(Decorator)</p><p>  重要程度：3</p></li><li><p>外观模式(Facade)</p><p>  重要程度：5</p></li><li><p>享元模式(Flyweight)</p><p>  重要程度：1</p></li><li><p>代理模式(Proxy)</p><p>  重要程度：4</p></li></ul><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</p><p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</p><p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p><p>行为型模式分为类行为型模式和对象行为型模式两种：</p><ul><li>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</li><li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</li></ul><p><strong>包含模式</strong>(11种)</p><ul><li><p>职责链模式(Chain of Responsibility)</p><p>重要程度：3</p></li><li><p>命令模式(Command)</p><p>重要程度：4</p></li><li><p>解释器模式(Interpreter)</p><p>重要程度：1</p></li><li><p>迭代器模式(Iterator)</p><p>重要程度：5</p></li><li><p>中介者模式(Mediator)</p><p>重要程度：2</p></li><li><p>备忘录模式(Memento)</p><p>  重要程度：2</p></li><li><p>观察者模式(Observer)</p><p>  重要程度：5</p></li><li><p>状态模式(State)</p><p>  重要程度：3</p></li><li><p>策略模式(Strategy)</p><p>  重要程度：4</p></li><li><p>模板方法模式(Template Method)</p><p>  重要程度：3</p></li><li><p>访问者模式(Visitor)</p><p>  重要程度：1</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么是设计模式&quot;&gt;&lt;a href=&quot;#什么是设计模式&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式&quot;&gt;&lt;/a&gt;什么是设计模式&lt;/h5&gt;&lt;p&gt;&lt;em&gt;Christopher&lt;/em&gt; Alexander 说过：“每一个模式描述了一个在我们周围
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>23种设计模式/UML</title>
    <link href="https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML/"/>
    <id>https://mxdc.github.io/blog/1970/01/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-04-28T18:27:14.569Z</updated>
    
    <content type="html"><![CDATA[<h5 id="依赖关系（Dependency）"><a href="#依赖关系（Dependency）" class="headerlink" title="依赖关系（Dependency）"></a>依赖关系（Dependency）</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzAyMTkzMzIyMjUw?x-oss-process=image/format,png" alt=""></p><p>表示一个类对不在其实例作用域内的另一个类或对象的引用，通常有以下几种情况的依赖：</p><ol><li>局部变量</li><li>方法的参数或返回值</li><li>静态方法的调用</li></ol><h5 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系(Association)"></a>关联关系(Association)</h5><p>表示一个类持有另一个类或对象，是一种 “has-a” 关系，通常表现为：(Worker has Task)</p><ol><li><p>字段</p></li><li><p>属性</p><p><img src="https://img-blog.csdnimg.cn/20181127213855605.png" alt=""></p></li></ol><h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><h5 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系(Composition)"></a>组合关系(Composition)</h5><p>组合是整体和部分的关系，但是整体和部分不可分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Head head;<span class="comment">//组合，不可分离</span></span><br><span class="line">    <span class="keyword">private</span> IDcard idCard; <span class="comment">//聚合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h5><p><img src="https://img-blog.csdnimg.cn/20181127213803746.png" alt=""></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><img src="https://img-blog.csdnimg.cn/20181127213413278.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20181127213438552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lyb25fWWU=,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20181127213455173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lyb25fWWU=,size_16,color_FFFFFF,t_70" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;依赖关系（Dependency）&quot;&gt;&lt;a href=&quot;#依赖关系（Dependency）&quot; class=&quot;headerlink&quot; title=&quot;依赖关系（Dependency）&quot;&gt;&lt;/a&gt;依赖关系（Dependency）&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
